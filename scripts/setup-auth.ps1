# Script to configure Microsoft Entra ID authentication for Azure Functions
# Run this after 'azd up' completes

param(
    [Parameter(Mandatory=$false)]
    [string]$EnvironmentName = "gyc-dev",
    
    [Parameter(Mandatory=$false)]
    [int]$ClientSecretExpirationDays = 180,
    
    [Parameter(Mandatory=$false)]
    [string]$AIFoundryManagedIdentityId = $null
)

Write-Host "Setting up Microsoft Entra ID authentication..." -ForegroundColor Green

# Get deployment details from azd
Write-Host "Getting deployment details from azd..." -ForegroundColor Yellow
$azdEnvValues = azd env get-values --environment $EnvironmentName 2>$null

$functionAppName = $null
$resourceGroup = $null

if ($azdEnvValues) {
    $functionAppNameLine = $azdEnvValues | Select-String "AZURE_FUNCTION_NAME"
    if ($functionAppNameLine) {
        $functionAppName = ($functionAppNameLine.ToString() -split '=')[1].Trim('"')
    }
    
    $resourceGroupLine = $azdEnvValues | Select-String "AZURE_RESOURCE_GROUP_NAME"
    if ($resourceGroupLine) {
        $resourceGroup = ($resourceGroupLine.ToString() -split '=')[1].Trim('"')
    }
}

if ([string]::IsNullOrEmpty($functionAppName) -or [string]::IsNullOrEmpty($resourceGroup)) {
    Write-Host "Querying Azure for function app details..." -ForegroundColor Yellow
    
    # Get all function apps with the environment tag
    $functionApps = az functionapp list --query "[?tags.\`"azd-env-name\`"=='$EnvironmentName']" | ConvertFrom-Json
    
    if ($functionApps -and $functionApps.Count -gt 0) {
        $functionAppName = $functionApps[0].name
        $resourceGroup = $functionApps[0].resourceGroup
    } else {
        Write-Error "Could not find function app for environment: $EnvironmentName"
        Write-Host "Available environments:" -ForegroundColor Yellow
        azd env list
        exit 1
    }
}

Write-Host "Function App: $functionAppName" -ForegroundColor Cyan
Write-Host "Resource Group: $resourceGroup" -ForegroundColor Cyan

# Get tenant ID
$tenantId = az account show --query tenantId -o tsv

# Get function app details
$functionAppId = az functionapp show --name $functionAppName --resource-group $resourceGroup --query id -o tsv
$functionAppUrl = "https://$functionAppName.azurewebsites.net"

Write-Host "`nCreating Azure AD App Registration..." -ForegroundColor Green

# Create app registration
$appRegistrationJson = az ad app create `
    --display-name $functionAppName `
    --sign-in-audience "AzureADMultipleOrgs" `
    --web-redirect-uris "$functionAppUrl/.auth/login/aad/callback" `
    --enable-id-token-issuance true `
    --query "{appId:appId, id:id}" -o json

$appRegistration = $appRegistrationJson | ConvertFrom-Json
$clientId = $appRegistration.appId
$objectId = $appRegistration.id

Write-Host "App Registration Created:" -ForegroundColor Green
Write-Host "  Client ID: $clientId" -ForegroundColor Cyan
Write-Host "  Object ID: $objectId" -ForegroundColor Cyan

# Create client secret
$secretEndDate = (Get-Date).AddDays($ClientSecretExpirationDays).ToString("yyyy-MM-ddTHH:mm:ssZ")
Write-Host "`nCreating client secret (expires in $ClientSecretExpirationDays days)..." -ForegroundColor Green

$secretJson = az ad app credential reset `
    --id $clientId `
    --append `
    --display-name "Generated by setup-auth.ps1" `
    --end-date $secretEndDate `
    --query "{password:password}" -o json

$secret = ($secretJson | ConvertFrom-Json).password
Write-Host "Client Secret: $secret" -ForegroundColor Yellow
Write-Host "  (Save this - it won't be shown again!)" -ForegroundColor Red

# Add App Role for AI Foundry agents
Write-Host "`nAdding App Role for AI Foundry agents..." -ForegroundColor Green

# Get existing app configuration
$existingAppJson = az rest --method GET `
    --uri "https://graph.microsoft.com/v1.0/applications/$objectId" `
    --headers "Content-Type=application/json"
$existingApp = $existingAppJson | ConvertFrom-Json

# Check if app role already exists
$existingAppRole = $existingApp.appRoles | Where-Object { $_.value -eq "Access.Function.MCP" }

if ($existingAppRole) {
    Write-Host "  App role 'Access.Function.MCP' already exists" -ForegroundColor Yellow
    $appRoleId = $existingAppRole.id
} else {
    # Create new app role
    $appRoleId = (New-Guid).Guid
    $newAppRole = @{
        allowedMemberTypes = @("Application")
        description = "Allows Foundry agents to call MCP Function endpoints"
        displayName = "Access.Function.MCP"
        id = $appRoleId
        isEnabled = $true
        value = "Access.Function.MCP"
    }
    
    # Combine with existing app roles
    $allAppRoles = @($existingApp.appRoles) + @($newAppRole)
    $appRoleBody = @{ appRoles = $allAppRoles } | ConvertTo-Json -Depth 10
    $appRoleTempFile = [System.IO.Path]::GetTempFileName()
    $appRoleBody | Out-File -FilePath $appRoleTempFile -Encoding utf8 -NoNewline
    
    az rest --method PATCH `
        --uri "https://graph.microsoft.com/v1.0/applications/$objectId" `
        --headers "Content-Type=application/json" `
        --body "@$appRoleTempFile" | Out-Null
    
    Remove-Item $appRoleTempFile -ErrorAction SilentlyContinue
    Write-Host "  Created new app role" -ForegroundColor Green
    
    # Wait for Graph API to propagate
    Start-Sleep -Seconds 5
}

Write-Host "  App Role ID: $appRoleId" -ForegroundColor Cyan

# Grant App Role to AI Foundry managed identity if provided
if (-not [string]::IsNullOrEmpty($AIFoundryManagedIdentityId)) {
    Write-Host "`nGranting App Role to AI Foundry managed identity..." -ForegroundColor Green
    
    # Get the service principal for the app registration
    $spId = az ad sp list --filter "appId eq '$clientId'" --query "[0].id" -o tsv
    
    if ([string]::IsNullOrEmpty($spId)) {
        Write-Host "  Creating service principal for app registration..." -ForegroundColor Yellow
        $spId = az ad sp create --id $clientId --query id -o tsv
        # Wait for service principal creation to propagate
        Start-Sleep -Seconds 10
    }
    
    # Create app role assignment
    $assignmentBody = @{
        principalId = $AIFoundryManagedIdentityId
        resourceId = $spId
        appRoleId = $appRoleId
    } | ConvertTo-Json -Depth 10
    
    $assignmentTempFile = [System.IO.Path]::GetTempFileName()
    $assignmentBody | Out-File -FilePath $assignmentTempFile -Encoding utf8 -NoNewline
    
    try {
        az rest --method POST `
            --uri "https://graph.microsoft.com/v1.0/servicePrincipals/$AIFoundryManagedIdentityId/appRoleAssignments" `
            --headers "Content-Type=application/json" `
            --body "@$assignmentTempFile" | Out-Null
        
        Write-Host "  ✓ App role granted to AI Foundry identity: $AIFoundryManagedIdentityId" -ForegroundColor Green
    } catch {
        Write-Host "  ⚠ Failed to grant app role. You may need to do this manually in the Azure Portal." -ForegroundColor Yellow
        Write-Host "    Error: $_" -ForegroundColor Red
    }
    
    Remove-Item $assignmentTempFile -ErrorAction SilentlyContinue
} else {
    Write-Host "`n⚠ No AI Foundry managed identity specified. Skipping app role assignment." -ForegroundColor Yellow
    Write-Host "  To grant the role later, run:" -ForegroundColor Yellow
    Write-Host "  .\scripts\setup-auth.ps1 -AIFoundryManagedIdentityId <principal-id>" -ForegroundColor Cyan
}

# Add Microsoft Graph User.Read delegated permission
Write-Host "`nAdding Microsoft Graph User.Read permission..." -ForegroundColor Green
$graphApiId = "00000003-0000-0000-c000-000000000000" # Microsoft Graph
$userReadScopeId = "e1fe6dd8-ba31-4d61-89e7-88639da4683d" # User.Read

az ad app permission add `
    --id $clientId `
    --api $graphApiId `
    --api-permissions "$userReadScopeId=Scope" | Out-Null

# Expose API with default scope
Write-Host "`nExposing API with user_impersonation scope..." -ForegroundColor Green
$apiUri = "api://$clientId"

# Update identifier URIs first
az ad app update --id $clientId --identifier-uris $apiUri | Out-Null

# Refresh app configuration after identifier URI update
$existingAppJson = az rest --method GET `
    --uri "https://graph.microsoft.com/v1.0/applications/$objectId" `
    --headers "Content-Type=application/json"
$existingApp = $existingAppJson | ConvertFrom-Json

# Check if scope already exists
$existingScope = $existingApp.api.oauth2PermissionScopes | Where-Object { $_.value -eq "user_impersonation" }

if ($existingScope) {
    Write-Host "  Scope 'user_impersonation' already exists" -ForegroundColor Yellow
    $scopeId = $existingScope.id
    $allScopes = $existingApp.api.oauth2PermissionScopes
} else {
    # Create new scope
    $scopeId = (New-Guid).Guid
    $newScope = @{
        adminConsentDescription = "Allow the application to access $functionAppName on behalf of the signed-in user."
        adminConsentDisplayName = "Access $functionAppName"
        id = $scopeId
        isEnabled = $true
        type = "User"
        userConsentDescription = "Allow the application to access $functionAppName on your behalf."
        userConsentDisplayName = "Access $functionAppName"
        value = "user_impersonation"
    }
    
    # Combine with existing scopes
    $allScopes = @($existingApp.api.oauth2PermissionScopes) + @($newScope)
}

# Update API configuration
$apiConfig = @{
    requestedAccessTokenVersion = 2
    oauth2PermissionScopes = $allScopes
    preAuthorizedApplications = @()
}

$patchBody = @{ api = $apiConfig } | ConvertTo-Json -Depth 10
$tempFile = [System.IO.Path]::GetTempFileName()
$patchBody | Out-File -FilePath $tempFile -Encoding utf8 -NoNewline

az rest --method PATCH `
    --uri "https://graph.microsoft.com/v1.0/applications/$objectId" `
    --headers "Content-Type=application/json" `
    --body "@$tempFile" | Out-Null

Remove-Item $tempFile -ErrorAction SilentlyContinue

if (-not $existingScope) {
    Write-Host "  Created new scope" -ForegroundColor Green
    # Wait for Graph API to propagate
    Start-Sleep -Seconds 5
}

Write-Host "API exposed at: $apiUri" -ForegroundColor Cyan

# Configure Function App authentication
Write-Host "`nConfiguring Function App authentication..." -ForegroundColor Green

# Build auth settings
$subscriptionId = (az account show --query id -o tsv)
$authSettings = @{
    platform = @{
        enabled = $false  # Keep disabled to allow function key authentication
    }
    globalValidation = @{
        requireAuthentication = $false  # Keep disabled to allow function key authentication
        unauthenticatedClientAction = "AllowAnonymous"
    }
    identityProviders = @{
        azureActiveDirectory = @{
            enabled = $true
            registration = @{
                openIdIssuer = "https://login.microsoftonline.com/$tenantId/v2.0"
                clientId = $clientId
                clientSecretSettingName = "MICROSOFT_PROVIDER_AUTHENTICATION_SECRET"
            }
            validation = @{
                allowedAudiences = @($functionAppUrl, $apiUri)
            }
        }
    }
    login = @{
        tokenStore = @{
            # Disable token store for service-to-service authentication
            enabled = $false
        }
    }
}

$authSettingsJson = @{ properties = $authSettings } | ConvertTo-Json -Depth 10
$authTempFile = [System.IO.Path]::GetTempFileName()
$authSettingsJson | Out-File -FilePath $authTempFile -Encoding utf8 -NoNewline

# Update auth configuration
$authUri = "/subscriptions/$subscriptionId/resourceGroups/$resourceGroup/providers/Microsoft.Web/sites/$functionAppName/config/authsettingsV2?api-version=2023-12-01"

az rest --method PUT `
    --uri $authUri `
    --headers "Content-Type=application/json" `
    --body "@$authTempFile" | Out-Null

Remove-Item $authTempFile -ErrorAction SilentlyContinue

# Update app settings with the API scope and client secret
Write-Host "`nUpdating app settings..." -ForegroundColor Green
az functionapp config appsettings set `
    --name $functionAppName `
    --resource-group $resourceGroup `
    --settings `
        "WEBSITE_AUTH_PRM_DEFAULT_WITH_SCOPES=$apiUri/user_impersonation" `
        "MICROSOFT_PROVIDER_AUTHENTICATION_SECRET=$secret" | Out-Null

Write-Host "`n✓ Authentication setup complete!" -ForegroundColor Green
Write-Host "`nConfiguration Summary:" -ForegroundColor Yellow
Write-Host "  Function App: $functionAppUrl" -ForegroundColor Cyan
Write-Host "  Client ID: $clientId" -ForegroundColor Cyan
Write-Host "  API URI: $apiUri" -ForegroundColor Cyan
Write-Host "  Default Scope: $apiUri/user_impersonation" -ForegroundColor Cyan
Write-Host "  App Role: Access.Function.MCP" -ForegroundColor Cyan
Write-Host "  Client Application Requirement: Allow requests from any application" -ForegroundColor Cyan
Write-Host "  Token Store: Disabled (supports service-to-service auth)" -ForegroundColor Cyan
Write-Host "  EasyAuth: DISABLED (allows function key authentication)" -ForegroundColor Cyan
Write-Host "  Note: App registration created but EasyAuth disabled to preserve function key access" -ForegroundColor Yellow
Write-Host "`nNext steps:" -ForegroundColor Yellow
if ([string]::IsNullOrEmpty($AIFoundryManagedIdentityId)) {
    Write-Host "  1. Grant the 'Access.Function.MCP' app role to your AI Foundry agent's managed identity" -ForegroundColor White
    Write-Host "     Run: .\scripts\setup-auth.ps1 -AIFoundryManagedIdentityId <principal-id>" -ForegroundColor Cyan
    Write-Host "  2. Test authentication in Azure Portal" -ForegroundColor White
    Write-Host "  3. Grant admin consent for Microsoft Graph permissions (if needed)" -ForegroundColor White
    Write-Host "  4. Update your AI Foundry agent with the new endpoint" -ForegroundColor White
} else {
    Write-Host "  1. Test authentication in Azure Portal" -ForegroundColor White
    Write-Host "  2. Grant admin consent for Microsoft Graph permissions (if needed)" -ForegroundColor White
    Write-Host "  3. Update your AI Foundry agent with the new endpoint" -ForegroundColor White
}
